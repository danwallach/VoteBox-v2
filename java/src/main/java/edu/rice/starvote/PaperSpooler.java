package edu.rice.starvote;

import com.pi4j.io.gpio.PinEdge;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Reference implementation of ballot box paper feeder controller. The entire ballot feeding and processing sequence
 * is controlled by this module.
 *
 * @author luejerry
 */
public class PaperSpooler implements ISpooler {

    final static int SCANTIME = 4;

    private DeviceStatus status = DeviceStatus.READY;
    private final IStatusUpdate statusUpdater;
    private final IDiverter diverter;
    private final IMotor motor;
    private final GPIOListener halfwaySensor;
    private final IScanner scanner;
    private final IValidator validator;

    /**
     * Constructor. All dependency components must be supplied.
     *
     * @param statusUpdater Ballot status updater module.
     * @param diverter Ballot accept/reject diverter module.
     * @param motor Printer motor controller module.
     * @param halfwaySensor Internal printer paper sensor (HP1010 specific): reads LOW when paper is halfway through
     *                      the feed path.
     * @param scanner Code scanner module.
     * @param validator Code validator module.
     */
    public PaperSpooler(IStatusUpdate statusUpdater,
                        IDiverter diverter,
                        IMotor motor,
                        GPIOListener halfwaySensor,
                        IScanner scanner,
                        IValidator validator) {
        this.statusUpdater = statusUpdater;
        this.diverter = diverter;
        this.motor = motor;
        this.halfwaySensor = halfwaySensor;
        this.scanner = scanner;
        this.validator = validator;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DeviceStatus getStatus() {
        return status;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public synchronized void takeIn() {
        /*
         * This implementation is fully event-driven by sensor interrupts, rather than polling. The expected sequence
         * of execution is:
         *
         *  1. Signal ballot status is SPOOLING ("pending").
         *  2. Feed in paper (motor forward).
         *  3. Event generated by halfway sensor.
         *  4. Eject paper slow (motor reverse slow).
         *  5. Scan and validate code.
         *  6. Signal ballot status is ACCEPT or REJECT.
         *  6. Actuate diverter to appropriate path (accept/reject).
         *  7. Eject paper (motor reverse).
         *  8. Event generated by halfway sensor.
         *  9. Stop feed motor.
         * 10. Signal ballot status is WAITING.
         *
         * Because event handlers execute concurrently with the main thread and each other, care must be taken to
         * ensure synchronization and ordering constraints do not allow the machine to enter an inconsistent state.
         */

        // Used by the final event handler to signal the main thread to continue
        final CountDownLatch signalDone = new CountDownLatch(1);

        statusUpdater.pushStatus(BallotStatus.SPOOLING);
        status = DeviceStatus.BUSY;

        diverter.up();
        motor.forward();

        // Register the event handler for paper entering the halfway sensor.
        if (!halfwaySensor.waitForEvent(PinEdge.FALLING, () -> {
            System.out.println("Paper taken in, beginning scan");
            try {
                TimeUnit.MILLISECONDS.sleep(100);
            } catch (InterruptedException e) {
                System.err.println(e.toString());
            }
            motor.reverseSlow();
            String code = scanner.scan(SCANTIME);
            motor.stop();
            // TODO: add delays for accept/reject messages
            if (code.isEmpty()) {
                System.out.println("Ballot not scanned");
                statusUpdater.pushStatus(BallotStatus.REJECT);
                diverter.up();
            } else {
                if (validator.validate(code)) {
                    System.out.println("Ballot code valid");
                    statusUpdater.pushStatus(BallotStatus.ACCEPT);
                    diverter.down();
                } else {
                    System.out.println("Ballot code invalid");
                    statusUpdater.pushStatus(BallotStatus.REJECT);
                    diverter.up();
                }
            }
            try {
                // Time to allow diverter to fully actuate
                TimeUnit.MILLISECONDS.sleep(1000);
            } catch (InterruptedException e) {
                System.err.println(e.toString());
            }
            motor.reverse();

            // Register the event handler for paper exiting the halfway sensor.
            if (!halfwaySensor.waitForEvent(PinEdge.RISING, () -> {
                System.out.println("Spooler cleared");
                try {
                    TimeUnit.MILLISECONDS.sleep(500);
                } catch (InterruptedException ignored) {}
                motor.stop();
                status = DeviceStatus.READY;
                statusUpdater.pushStatus(BallotStatus.WAITING);
                signalDone.countDown();
            }, 2000)) {
                // This block executes if paper exit event not occur within 2s (paper jammed in feeder).
                if (halfwaySensor.getState().isLow()) {
                    // Paper still in feeder, abort with error
                    System.out.println("Spooler jammed");
//                motor.reverse();
//                try {
//                    TimeUnit.SECONDS.sleep(2);
//                } catch (InterruptedException e) {
//                    System.err.println(e.toString());
//                }
                    motor.stop();
                    status = DeviceStatus.ERROR;
                    statusUpdater.pushStatus(BallotStatus.OFFLINE);
                } else {
                    // Feeder is clear, continue
                    System.out.println("Spooler checked clear");
                    motor.stop();
                    status = DeviceStatus.READY;
                    statusUpdater.pushStatus(BallotStatus.WAITING);
                }

                // Signal main thread to continue
                signalDone.countDown();
            }
        }, 2000)) {
            // This block executes if paper entrance event does not occur in 2s (paper tray was empty).
            System.out.println("Paper tray empty");

            // Reset the feeder
            motor.reverse();
            try {
                TimeUnit.MILLISECONDS.sleep(500);
            } catch (InterruptedException e) {
                System.err.println(e.toString());
            }
            motor.stop();
            
            status = DeviceStatus.READY;
            statusUpdater.pushStatus(BallotStatus.WAITING);

            // Signal main thread to continue
            signalDone.countDown();
        }

        // Main thread
        try {
            final boolean completed = signalDone.await(15000, TimeUnit.MILLISECONDS);
            System.out.println(completed ? "Paper spool complete" : "Paper spool timed out");
        } catch (InterruptedException e) {
            System.err.println(e.toString());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void eject() {

    }
}
